// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// The JSON schema for the Shift database configuration file.
type SchemaJson struct {
	// The URL to the Shift schema.
	Schema string `json:"$schema" yaml:"$schema" mapstructure:"$schema"`

	// The database configuration for the migration to use.
	Database SchemaJsonDatabase `json:"database" yaml:"database" mapstructure:"database"`

	// The tables to manage in the migration.
	Tables []SchemaJsonTablesElem `json:"tables" yaml:"tables" mapstructure:"tables"`

	// The version of the Shift configuration file.
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

// The database configuration for the migration to use.
type SchemaJsonDatabase struct {
	// Url corresponds to the JSON schema field "url".
	Url interface{} `json:"url" yaml:"url" mapstructure:"url"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJsonDatabase) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in SchemaJsonDatabase: required")
	}
	type Plain SchemaJsonDatabase
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SchemaJsonDatabase(plain)
	return nil
}

// The table definition
type SchemaJsonTablesElem struct {
	// The columns that are part of the table.
	Columns []SchemaJsonTablesElemColumnsElem `json:"columns" yaml:"columns" mapstructure:"columns"`

	// The description of the table.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The name of the table.
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// The column definition
type SchemaJsonTablesElemColumnsElem struct {
	// Whether the column is auto-incrementing.
	AutoIncrement *bool `json:"autoIncrement,omitempty" yaml:"autoIncrement,omitempty" mapstructure:"autoIncrement,omitempty"`

	// The specific native database default value if no value is provided.
	Default *SchemaJsonTablesElemColumnsElemDefault `json:"default,omitempty" yaml:"default,omitempty" mapstructure:"default,omitempty"`

	// The description of the column.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Whether the column is indexed.
	Index *bool `json:"index,omitempty" yaml:"index,omitempty" mapstructure:"index,omitempty"`

	// If the type represents an array.
	IsArray bool `json:"isArray,omitempty" yaml:"isArray,omitempty" mapstructure:"isArray,omitempty"`

	// The exact length for a number type.
	Length *SchemaJsonTablesElemColumnsElemLength `json:"length,omitempty" yaml:"length,omitempty" mapstructure:"length,omitempty"`

	// The max length of the column.
	MaxLength *int `json:"maxLength,omitempty" yaml:"maxLength,omitempty" mapstructure:"maxLength,omitempty"`

	// The name of the column.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The specific native database type which overrides the generic type.
	NativeType *SchemaJsonTablesElemColumnsElemNativeType `json:"nativeType,omitempty" yaml:"nativeType,omitempty" mapstructure:"nativeType,omitempty"`

	// Whether the column is nullable.
	Nullable *bool `json:"nullable,omitempty" yaml:"nullable,omitempty" mapstructure:"nullable,omitempty"`

	// Whether the column is a primary key.
	PrimaryKey *bool `json:"primaryKey,omitempty" yaml:"primaryKey,omitempty" mapstructure:"primaryKey,omitempty"`

	// The foreign key reference for the column.
	References *SchemaJsonTablesElemColumnsElemReferences `json:"references,omitempty" yaml:"references,omitempty" mapstructure:"references,omitempty"`

	// The generic subtype of the column.
	Subtype *SchemaJsonTablesElemColumnsElemSubtype `json:"subtype,omitempty" yaml:"subtype,omitempty" mapstructure:"subtype,omitempty"`

	// The generic data type of the column.
	Type SchemaJsonTablesElemColumnsElemType `json:"type" yaml:"type" mapstructure:"type"`

	// Whether the column is unique.
	Unique *bool `json:"unique,omitempty" yaml:"unique,omitempty" mapstructure:"unique,omitempty"`
}

// The specific native database default value if no value is provided.
type SchemaJsonTablesElemColumnsElemDefault struct {
	// The native MySQL default value.
	Mysql *string `json:"mysql,omitempty" yaml:"mysql,omitempty" mapstructure:"mysql,omitempty"`

	// The native Postgres default value.
	Postgres *string `json:"postgres,omitempty" yaml:"postgres,omitempty" mapstructure:"postgres,omitempty"`

	// The native SQLite default value.
	Sqlite *string `json:"sqlite,omitempty" yaml:"sqlite,omitempty" mapstructure:"sqlite,omitempty"`
}

// The exact length for a number type.
type SchemaJsonTablesElemColumnsElemLength struct {
	// Precision corresponds to the JSON schema field "precision".
	Precision int `json:"precision" yaml:"precision" mapstructure:"precision"`

	// Scale corresponds to the JSON schema field "scale".
	Scale *float64 `json:"scale,omitempty" yaml:"scale,omitempty" mapstructure:"scale,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJsonTablesElemColumnsElemLength) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["precision"]; raw != nil && !ok {
		return fmt.Errorf("field precision in SchemaJsonTablesElemColumnsElemLength: required")
	}
	type Plain SchemaJsonTablesElemColumnsElemLength
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 1000 < plain.Precision {
		return fmt.Errorf("field %s: must be <= %v", "precision", 1000)
	}
	if 1 > plain.Precision {
		return fmt.Errorf("field %s: must be >= %v", "precision", 1)
	}
	if plain.Scale != nil && 1000 < *plain.Scale {
		return fmt.Errorf("field %s: must be <= %v", "scale", 1000)
	}
	if plain.Scale != nil && -1000 > *plain.Scale {
		return fmt.Errorf("field %s: must be >= %v", "scale", -1000)
	}
	*j = SchemaJsonTablesElemColumnsElemLength(plain)
	return nil
}

// The specific native database type which overrides the generic type.
type SchemaJsonTablesElemColumnsElemNativeType struct {
	// The native MySQL data type.
	Mysql *string `json:"mysql,omitempty" yaml:"mysql,omitempty" mapstructure:"mysql,omitempty"`

	// The native Postgres data type.
	Postgres *string `json:"postgres,omitempty" yaml:"postgres,omitempty" mapstructure:"postgres,omitempty"`

	// The native SQLite data type.
	Sqlite *string `json:"sqlite,omitempty" yaml:"sqlite,omitempty" mapstructure:"sqlite,omitempty"`
}

// The foreign key reference for the column.
type SchemaJsonTablesElemColumnsElemReferences struct {
	// The foreign column the column references.
	Column string `json:"column" yaml:"column" mapstructure:"column"`

	// The foreign table the column references.
	Table string `json:"table" yaml:"table" mapstructure:"table"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJsonTablesElemColumnsElemReferences) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["column"]; raw != nil && !ok {
		return fmt.Errorf("field column in SchemaJsonTablesElemColumnsElemReferences: required")
	}
	if _, ok := raw["table"]; raw != nil && !ok {
		return fmt.Errorf("field table in SchemaJsonTablesElemColumnsElemReferences: required")
	}
	type Plain SchemaJsonTablesElemColumnsElemReferences
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SchemaJsonTablesElemColumnsElemReferences(plain)
	return nil
}

type SchemaJsonTablesElemColumnsElemSubtype string

const SchemaJsonTablesElemColumnsElemSubtypeBinary SchemaJsonTablesElemColumnsElemSubtype = "binary"
const SchemaJsonTablesElemColumnsElemSubtypeBit SchemaJsonTablesElemColumnsElemSubtype = "bit"
const SchemaJsonTablesElemColumnsElemSubtypeJson SchemaJsonTablesElemColumnsElemSubtype = "json"
const SchemaJsonTablesElemColumnsElemSubtypeUuid SchemaJsonTablesElemColumnsElemSubtype = "uuid"

var enumValues_SchemaJsonTablesElemColumnsElemSubtype = []interface{}{
	"json",
	"binary",
	"bit",
	"uuid",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJsonTablesElemColumnsElemSubtype) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SchemaJsonTablesElemColumnsElemSubtype {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SchemaJsonTablesElemColumnsElemSubtype, v)
	}
	*j = SchemaJsonTablesElemColumnsElemSubtype(v)
	return nil
}

type SchemaJsonTablesElemColumnsElemType string

const SchemaJsonTablesElemColumnsElemTypeBoolean SchemaJsonTablesElemColumnsElemType = "boolean"
const SchemaJsonTablesElemColumnsElemTypeDatetime SchemaJsonTablesElemColumnsElemType = "datetime"
const SchemaJsonTablesElemColumnsElemTypeFloat SchemaJsonTablesElemColumnsElemType = "float"
const SchemaJsonTablesElemColumnsElemTypeInt SchemaJsonTablesElemColumnsElemType = "int"
const SchemaJsonTablesElemColumnsElemTypeString SchemaJsonTablesElemColumnsElemType = "string"

var enumValues_SchemaJsonTablesElemColumnsElemType = []interface{}{
	"string",
	"int",
	"float",
	"boolean",
	"datetime",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJsonTablesElemColumnsElemType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SchemaJsonTablesElemColumnsElemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SchemaJsonTablesElemColumnsElemType, v)
	}
	*j = SchemaJsonTablesElemColumnsElemType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJsonTablesElemColumnsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in SchemaJsonTablesElemColumnsElem: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in SchemaJsonTablesElemColumnsElem: required")
	}
	type Plain SchemaJsonTablesElemColumnsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["isArray"]; !ok || v == nil {
		plain.IsArray = false
	}
	if plain.MaxLength != nil && 65535 < *plain.MaxLength {
		return fmt.Errorf("field %s: must be <= %v", "maxLength", 65535)
	}
	if plain.MaxLength != nil && 0 >= *plain.MaxLength {
		return fmt.Errorf("field %s: must be > %v", "maxLength", 0)
	}
	*j = SchemaJsonTablesElemColumnsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJsonTablesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["columns"]; raw != nil && !ok {
		return fmt.Errorf("field columns in SchemaJsonTablesElem: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in SchemaJsonTablesElem: required")
	}
	type Plain SchemaJsonTablesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SchemaJsonTablesElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["$schema"]; raw != nil && !ok {
		return fmt.Errorf("field $schema in SchemaJson: required")
	}
	if _, ok := raw["database"]; raw != nil && !ok {
		return fmt.Errorf("field database in SchemaJson: required")
	}
	if _, ok := raw["tables"]; raw != nil && !ok {
		return fmt.Errorf("field tables in SchemaJson: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in SchemaJson: required")
	}
	type Plain SchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Tables != nil && len(plain.Tables) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "tables", 1)
	}
	*j = SchemaJson(plain)
	return nil
}
