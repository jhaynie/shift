// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// The JSON schema for the Shift database configuration file.
type SchemaJson struct {
	// The database configuration for the migration to use.
	Database SchemaJsonDatabase `json:"database" yaml:"database" mapstructure:"database"`

	// The tables to manage in the migration.
	Tables []SchemaJsonTablesElem `json:"tables" yaml:"tables" mapstructure:"tables"`

	// The version of the Shift configuration file.
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

// The database configuration for the migration to use.
type SchemaJsonDatabase struct {
	// The database driver to use for the migration.
	Driver SchemaJsonDatabaseDriver `json:"driver" yaml:"driver" mapstructure:"driver"`

	// The database driver URL for connecting to the database.
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

type SchemaJsonDatabaseDriver string

const SchemaJsonDatabaseDriverMysql SchemaJsonDatabaseDriver = "mysql"
const SchemaJsonDatabaseDriverPostgres SchemaJsonDatabaseDriver = "postgres"
const SchemaJsonDatabaseDriverSqlite SchemaJsonDatabaseDriver = "sqlite"

var enumValues_SchemaJsonDatabaseDriver = []interface{}{
	"mysql",
	"postgres",
	"sqlite",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJsonDatabaseDriver) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SchemaJsonDatabaseDriver {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SchemaJsonDatabaseDriver, v)
	}
	*j = SchemaJsonDatabaseDriver(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJsonDatabase) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["driver"]; raw != nil && !ok {
		return fmt.Errorf("field driver in SchemaJsonDatabase: required")
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in SchemaJsonDatabase: required")
	}
	type Plain SchemaJsonDatabase
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SchemaJsonDatabase(plain)
	return nil
}

// The table definition
type SchemaJsonTablesElem struct {
	// The columns to manage in the table.
	Columns []SchemaJsonTablesElemColumnsElem `json:"columns" yaml:"columns" mapstructure:"columns"`

	// The name of the table.
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// The column definition
type SchemaJsonTablesElemColumnsElem struct {
	// Whether the column is auto-incrementing.
	AutoIncrement *bool `json:"autoIncrement,omitempty" yaml:"autoIncrement,omitempty" mapstructure:"autoIncrement,omitempty"`

	// The default value of the column.
	Default *string `json:"default,omitempty" yaml:"default,omitempty" mapstructure:"default,omitempty"`

	// The description of the column.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Whether the column is indexed.
	Index *bool `json:"index,omitempty" yaml:"index,omitempty" mapstructure:"index,omitempty"`

	// The max length of the column.
	Length *int `json:"length,omitempty" yaml:"length,omitempty" mapstructure:"length,omitempty"`

	// The name of the column.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Specify a specific native database type which overrides the type.
	NativeType *string `json:"nativeType,omitempty" yaml:"nativeType,omitempty" mapstructure:"nativeType,omitempty"`

	// Whether the column is nullable.
	Nullable *bool `json:"nullable,omitempty" yaml:"nullable,omitempty" mapstructure:"nullable,omitempty"`

	// Whether the column is a primary key.
	PrimaryKey *bool `json:"primaryKey,omitempty" yaml:"primaryKey,omitempty" mapstructure:"primaryKey,omitempty"`

	// The foreign key reference for the column.
	References *SchemaJsonTablesElemColumnsElemReferences `json:"references,omitempty" yaml:"references,omitempty" mapstructure:"references,omitempty"`

	// The type subtype of the column.
	Subtype *SchemaJsonTablesElemColumnsElemSubtype `json:"subtype,omitempty" yaml:"subtype,omitempty" mapstructure:"subtype,omitempty"`

	// The data type of the column.
	Type SchemaJsonTablesElemColumnsElemType `json:"type" yaml:"type" mapstructure:"type"`

	// Whether the column is unique.
	Unique *bool `json:"unique,omitempty" yaml:"unique,omitempty" mapstructure:"unique,omitempty"`
}

// The foreign key reference for the column.
type SchemaJsonTablesElemColumnsElemReferences struct {
	// The column the column references.
	Column string `json:"column" yaml:"column" mapstructure:"column"`

	// The table the column references.
	Table string `json:"table" yaml:"table" mapstructure:"table"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJsonTablesElemColumnsElemReferences) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["column"]; raw != nil && !ok {
		return fmt.Errorf("field column in SchemaJsonTablesElemColumnsElemReferences: required")
	}
	if _, ok := raw["table"]; raw != nil && !ok {
		return fmt.Errorf("field table in SchemaJsonTablesElemColumnsElemReferences: required")
	}
	type Plain SchemaJsonTablesElemColumnsElemReferences
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SchemaJsonTablesElemColumnsElemReferences(plain)
	return nil
}

type SchemaJsonTablesElemColumnsElemSubtype string

const SchemaJsonTablesElemColumnsElemSubtypeArray SchemaJsonTablesElemColumnsElemSubtype = "array"
const SchemaJsonTablesElemColumnsElemSubtypeBinary SchemaJsonTablesElemColumnsElemSubtype = "binary"
const SchemaJsonTablesElemColumnsElemSubtypeBit SchemaJsonTablesElemColumnsElemSubtype = "bit"
const SchemaJsonTablesElemColumnsElemSubtypeJson SchemaJsonTablesElemColumnsElemSubtype = "json"
const SchemaJsonTablesElemColumnsElemSubtypeUuid SchemaJsonTablesElemColumnsElemSubtype = "uuid"

var enumValues_SchemaJsonTablesElemColumnsElemSubtype = []interface{}{
	"json",
	"array",
	"binary",
	"bit",
	"uuid",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJsonTablesElemColumnsElemSubtype) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SchemaJsonTablesElemColumnsElemSubtype {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SchemaJsonTablesElemColumnsElemSubtype, v)
	}
	*j = SchemaJsonTablesElemColumnsElemSubtype(v)
	return nil
}

type SchemaJsonTablesElemColumnsElemType string

const SchemaJsonTablesElemColumnsElemTypeBoolean SchemaJsonTablesElemColumnsElemType = "boolean"
const SchemaJsonTablesElemColumnsElemTypeDatetime SchemaJsonTablesElemColumnsElemType = "datetime"
const SchemaJsonTablesElemColumnsElemTypeFloat SchemaJsonTablesElemColumnsElemType = "float"
const SchemaJsonTablesElemColumnsElemTypeInt SchemaJsonTablesElemColumnsElemType = "int"
const SchemaJsonTablesElemColumnsElemTypeString SchemaJsonTablesElemColumnsElemType = "string"

var enumValues_SchemaJsonTablesElemColumnsElemType = []interface{}{
	"string",
	"int",
	"float",
	"boolean",
	"datetime",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJsonTablesElemColumnsElemType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SchemaJsonTablesElemColumnsElemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SchemaJsonTablesElemColumnsElemType, v)
	}
	*j = SchemaJsonTablesElemColumnsElemType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJsonTablesElemColumnsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in SchemaJsonTablesElemColumnsElem: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in SchemaJsonTablesElemColumnsElem: required")
	}
	type Plain SchemaJsonTablesElemColumnsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Length != nil && 65535 < *plain.Length {
		return fmt.Errorf("field %s: must be <= %v", "length", 65535)
	}
	if plain.Length != nil && 0 >= *plain.Length {
		return fmt.Errorf("field %s: must be > %v", "length", 0)
	}
	*j = SchemaJsonTablesElemColumnsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJsonTablesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["columns"]; raw != nil && !ok {
		return fmt.Errorf("field columns in SchemaJsonTablesElem: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in SchemaJsonTablesElem: required")
	}
	type Plain SchemaJsonTablesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SchemaJsonTablesElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["database"]; raw != nil && !ok {
		return fmt.Errorf("field database in SchemaJson: required")
	}
	if _, ok := raw["tables"]; raw != nil && !ok {
		return fmt.Errorf("field tables in SchemaJson: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in SchemaJson: required")
	}
	type Plain SchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Tables != nil && len(plain.Tables) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "tables", 1)
	}
	*j = SchemaJson(plain)
	return nil
}
